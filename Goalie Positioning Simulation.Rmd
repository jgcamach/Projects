# -------------------------
#  USER-TUNABLE PARAMETERS
# -------------------------
A <- seq(-1.5,0, by = 0.1)         # striker x coordinates
B <- seq(0,3, by = 0.1)            # striker y coordinates
E <- seq(0.165, 1.835, by = 0.01)  # discrete targets along the goal mouth
v <- (1/0.66) * 3.2                # ball speed (leaps/sec)
t0 <- 0.11                         # reaction delay (seconds) - when goalie starts moving
max_leap_time <- 0.66              # time to travel one leap (seconds)
dt <- 0.02                         # discrete time step (seconds)
P_x <- -1 + E                      # target x positions on goal line (y=0)
n_shots <- length(E)

# coarse grid search resolution
x_grid <- seq(-1.5, 1.5, by = 0.01)   # candidate goalie x start positions
y_grid <- seq(-0.02, 1.5, by = 0.01)   # candidate goalie y start positions

# -------------------------
#  Build coarse grid of goalie starting positions
# -------------------------
grid_coarse <- expand.grid(x = x_grid, y = y_grid)
n_grid_coarse <- nrow(grid_coarse)

#Storing results
results_df <- data.frame(
  striker_x = numeric(0),
  striker_y = numeric(0),
  goalie_x = numeric(0),
  goalie_y = numeric(0),
  goalie_prob = numeric(0)
)

#
r_of_t <- function(t){
  # returns radius in leaps
  # 0 for t <= t0; grows linearly as (t - t0)/0.66 until capped at 1
  r <- ifelse(
    t <= t0, 0, pmin( (t-t0) / max_leap_time, 1.0)
    )
  return(r)
}

# -------------------------
#  Simulating Shots
# -------------------------
for(a in A){
  for(b in B){
    cat("Simulating striker at (", a, "," , b, ")\n")
    
    coverage_counts_coarse <- integer(n_grid_coarse)  # how many shots

    # -------------------------
    #  Derived / precomputed shot geometry
    # -------------------------
    dx <- P_x - a
    dy <- -b
    d_e <- sqrt(dx^2 + b^2)        # distance striker -> target for each shot
    d_e[d_e == 0] <- 1e-12
    ux <- dx / d_e                 # shot unit x-direction
    uy <- dy / d_e                 # shot unit y-direction (negative value)
    T_e <- d_e / v                 # time for each shot to reach goal line

    
    
    # -------------------------
    #  MAIN LOOP (coarse): for each shot, pre-compute time steps and radii, evaluate vectorized distances
    #  We pre-compute time steps and radius values for each shot to skip time steps where r=0.
    # -------------------------
    for(j in seq_len(n_shots)){
      Tj <- T_e[j]
      # discretize time from 0 to Tj (inclusive). If Tj < dt, include at least 0 and Tj.
      if(Tj <= 0){
        next
      }
      t_steps <- seq(0, Tj, by = dt)
      if(tail(t_steps, 1) < Tj) t_steps <- c(t_steps, Tj)
      r_vals <- r_of_t(t_steps)    # vector of radii (leaps) corresponding to times
      # skip times where radius is zero (before reaction)
      use_idx <- which(r_vals > 0)
      if(length(use_idx) == 0){
        # no time during flight where goalie has positive radius -> cannot save this shot
        next
      }
      # Pre-compute constants for shot direction
      uxj <- ux[j]; uyj <- uy[j]
      # For each shot we keep a Boolean saved_by_grid indicating if each grid point can save this shot
      saved_by_grid <- rep(FALSE, n_grid_coarse)
      # Evaluate only the time steps after reaction: vectorized across grid
      for(k in use_idx){
        tt <- t_steps[k]
        rtt <- r_vals[k]
        # ball position at time tt
        Sx <- a + v * tt * uxj
        Sy <- b + v * tt * uyj
        dxg <- grid_coarse$x - Sx
        dyg <- grid_coarse$y - Sy
        dist_to_ball <- sqrt(dxg * dxg + dyg * dyg)
        can_save_now <- dist_to_ball <= rtt
        # update saved_by_grid - once TRUE it stays TRUE for this shot
        newly_saved <- which(can_save_now & !saved_by_grid)
        if(length(newly_saved) > 0){
          saved_by_grid[newly_saved] <- TRUE
          # minor optimization: if all grid points already can save this shot, stop time loop
          if(all(saved_by_grid)) break
        }
      } # end time loop
      # accumulate coverage counts
      coverage_counts_coarse <- coverage_counts_coarse + as.integer(saved_by_grid)
      if(j %% 50 == 0) cat("Coarse processed shot", j, " / ", n_shots, "\n")
    } # end shot loop
    
    # attach probabilities to grid
    prob_coarse <- coverage_counts_coarse / n_shots
    grid_coarse$prob <- prob_coarse
    
    # coarse best
    max_p_coarse <- max(prob_coarse)
    best_idx_coarse <- which(prob_coarse == max_p_coarse)
    best_pts_coarse <- grid_coarse[best_idx_coarse, , drop = FALSE]
    cat("Coarse best probability:", max_p_coarse, "found at", nrow(best_pts_coarse), "grid point(s)\n")
    
    results_df <- rbind(
      results_df,
      data.frame(
        striker_x = a,
        striker_y = b,
        goalie_x = best_pts_coarse$x,
        goalie_y = best_pts_coarse$y,
        goalie_prob = best_pts_coarse$prob,
        stringsAsFactors = F
      )
    )

  }
}
```


```{r}
#-------------------------
# Visualizing the Data
#-------------------------
library(ggplot2)
#Because the field is symmetric we can reflect the solutions over to the positive integers
symetric_y <- c(results_df$goalie_y, results_df$goalie_y)
symetric_x <- c(results_df$goalie_x,-results_df$goalie_x)
df <- data.frame(symetric_x, symetric_y)

#Plot of the best goalie positions
ggplot(df,  aes(symetric_x, symetric_y))+
  geom_point( size = 0.5)


#Approximated Vector Field of striker position to best goalie position
#Vectors have been normalized to a 1/10 of a unit vector for clarity. Color represents magnitude.

#normalizing vectors
vec_x <- results_df$goalie_x - results_df$striker_x
vec_y <- results_df$goalie_y - results_df$striker_y

magnitude <- sqrt((vec_x^2 + vec_y^2))

vec_x <- (vec_x/magnitude)/10
vec_y <- (vec_y/magnitude)/10


ggplot(results_df,
       aes(
           goalie_x,
           goalie_y,
           )
       )+
  
  geom_count(aes(
                 goalie_x,
                 goalie_y, 
                 color = goalie_prob)
  )
#plotting
ggplot(results_df,
       aes(x = striker_x,
           y = striker_y)
       )+
  
  geom_segment(arrow = arrow(length = unit(0.01, "cm")),
               aes(x = striker_x,
                   y = striker_y,
                   xend = (striker_x + vec_x), 
                   yend = (striker_y + vec_y), 
                   colour = magnitude)) +
  
  scale_color_gradient(low = "green3",
                       high = "red")

#3d graph including probability as the z axis
library(rgl)
plot3d(x = results_df$striker_x,
       y = results_df$striker_y,
       z = results_df$goalie_prob)
